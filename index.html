<!DOCTYPE html>
<html lang="pl">
<head>
     crossorigin="anonymous"></script>
    <meta name="google-adsense-account" content="ca-pub-5486175208501620">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nasze Klipy + CS2</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #1e1e1e;
            color: #fff;
            text-align: center;
            padding: 20px;
        }
        h1 { margin-bottom: 40px; }
        .video-container { margin-bottom: 40px; }
        iframe { width: 80%; max-width: 560px; height: 315px; }

        /* Menu */
        nav { margin-bottom: 30px; }
        nav button { background-color: #333; color: white; border: none; padding: 10px 20px; margin: 5px; border-radius: 5px; cursor: pointer; }
        nav button:hover { background-color: #555; }

        /* Gry */
        #gameCanvas, #cs2Canvas { background-color: #222; display: block; margin: 0 auto; border: 2px solid white; }
        .controls { margin-top: 10px; }
        .hud { color: #fff; font-family: monospace; }
        .panel { margin-bottom: 10px; }
    </style>
</head>
<body>
    <!-- ZawartoÅ›Ä‡ strony -->
    <div id="content" style="display:block;">
        <nav>
            <button onclick="showSection('clips')">ðŸŽ¥ Klipy cebulka</button>
            <button onclick="showSection('game')">ðŸŽ® geometryjny dach</button>
            <button onclick="showSection('cs2')">ðŸ”« CS2</button>
        </nav>

        <!-- Sekcja z klipami -->
        <div id="clips">
            <h1>Klipy cebulka300</h1>

            <div class="video-container">
                <h2>Znany "kutavon"</h2>
                <iframe src="https://www.youtube.com/embed/6d7HCDqedlg" title="Kutavon 1" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
            </div>
            <p>Autor <b>Julus</b></p>

            <div class="video-container">
                <h2>Filmik 2</h2>
                <iframe src="https://www.youtube.com/embed/6d7HCDqedlg" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
            </div>

            <div class="video-container">
                <h2>Filmik 3</h2>
                <iframe src="https://www.youtube.com/embed/abcdefghijk" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
            </div>
        </div>

        <!-- Sekcja z Geometry Dash -->
        <div id="game" style="display:none;">
            <h1>Geometry Dash ðŸŸ¦ â€” Level 1</h1>
            <canvas id="gameCanvas" width="400" height="500"></canvas>
            <p>Kliknij lub naciÅ›nij spacjÄ™, Å¼eby podskoczyÄ‡!</p>
        </div>

        <!-- Sekcja CS2 -->
        <div id="cs2" style="display:none;">
            <h1>CS2 â€” tryb treningowy (2D)</h1>
            <div class="panel">
                <button id="startCs2">Start</button>
                <button id="restartCs2">Restart</button>
                <span class="hud"> Zdrowie: <span id="playerHealth">100</span> | Punkty: <span id="cs2Score">0</span></span>
            </div>
            <canvas id="cs2Canvas" width="900" height="500"></canvas>
            <div class="controls">
                Sterowanie: WASD â€” ruch, mysz â€” celowanie, lewy klik â€” strzaÅ‚, P â€” pauza.
            </div>
            <p style="font-size:12px; opacity:0.8;">Jedyna gra w ktorej cebulka moze zrobic wiecej killi niz 1</p>
        </div>
    </div>

    <script>
        function showSection(section) {
            document.getElementById('clips').style.display = 'none';
            document.getElementById('game').style.display = 'none';
            document.getElementById('cs2').style.display = 'none';
            document.getElementById(section).style.display = 'block';
        }

        /* ------------------------
           Geometry Dash (Level 1)
           ------------------------ */

        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");

        const G = { width: canvas.width, height: canvas.height, groundY: 420 };
        const player = { x: 80, y: G.groundY - 40, size: 34, vy: 0, gravity: 0.9, jumpPower: -15, onGround: true, color: '#00bfff' };
        let scrollSpeed = 4, gameStarted = false, gameOver = false, distance = 0;
        const obstacles = [];
        const levelPattern = [
            ['box', 250],['spike', 160],['spike', 60],['gap', 200],['box', 260],['box', 140],
            ['spike', 120],['gap', 220],['box', 260],['spike', 120],['box', 140],['gap', 180],
            ['spike', 130],['box', 200],['box', 140],['spike', 80],['gap', 260],['box', 280],
            ['spike', 120],['box', 140],['gap', 320],
        ];

        function buildLevel() {
            obstacles.length = 0;
            let x = G.width + 80;
            for (const item of levelPattern) {
                const type = item[0], offset = item[1];
                x += offset;
                if (type === 'spike') obstacles.push({ type: 'spike', x: x, w: 40, h: 26 }), x+=40;
                else if (type === 'box') obstacles.push({ type: 'box', x: x, w: 40, h: 40 }), x+=40;
                else if (type === 'gap') obstacles.push({ type: 'gap', x: x, w: offset, h: 0 }), x+=offset;
            }
            obstacles.push({ type: 'flag', x: x + 200, w: 20, h: 80 });
        }
        buildLevel();

        function resetGD() {
            player.y = G.groundY - player.size;
            player.vy = 0;
            player.onGround = true;
            gameStarted = false;
            gameOver = false;
            distance = 0;
            scrollSpeed = 4;
            buildLevel();
        }

        function doJump() {
            if (gameOver) { resetGD(); return; }
            if (!gameStarted) gameStarted = true;
            if (player.onGround) { player.vy = player.jumpPower; player.onGround = false; }
        }

        document.addEventListener('keydown', e => { if(e.code==='Space'){ e.preventDefault(); doJump(); } });
        canvas.addEventListener('mousedown', doJump);

        function rectsIntersect(rx, ry, rw, rh, px, py, pw, ph) { return !(px+pw<rx || px>rx+rw || py+ph<ry || py>ry+rh); }

        function updateGD() {
            if (!gameStarted || gameOver) return;
            player.vy += player.gravity;
            player.y += player.vy;
            if (player.y + player.size >= G.groundY) { player.y = G.groundY - player.size; player.vy=0; player.onGround=true; } else player.onGround=false;
            for (let i=obstacles.length-1;i>=0;i--){ const obj=obstacles[i]; obj.x-=scrollSpeed; if(obj.x+(obj.w||0)<-200) obstacles.splice(i,1);}
            distance += scrollSpeed*0.1;
            for (const obj of obstacles){ if(obj.type==='flag' && obj.x<player.x+40){ gameOver=true; gameStarted=false; scrollSpeed=0; } }
            for (const obj of obstacles){
                if(obj.type==='box'){ const bx=obj.x,by=G.groundY-obj.h,bw=obj.w,bh=obj.h; if(rectsIntersect(bx,by,bw,bh,player.x,player.y,player.size,player.size)) gameOver=true; }
                else if(obj.type==='spike'){ const sx=obj.x,sy=G.groundY-obj.h,sw=obj.w,sh=obj.h; if(rectsIntersect(sx,sy,sw,sh,player.x,player.y,player.size,player.size)) gameOver=true; }
                else if(obj.type==='gap'){ const gapX=obj.x,gapW=obj.w; if(player.x+player.size>gapX && player.x<gapX+gapW && player.onGround && !(player.y+player.size<G.groundY-0.1)){player.y+=2;player.onGround=false; } }
            }
            if(player.y>G.height+50 || player.y<-200) gameOver=true;
            if(distance>4000 && scrollSpeed<6) scrollSpeed=5;
            if(distance>8000 && scrollSpeed<7) scrollSpeed=6;
        }

        function drawGD() {
            ctx.fillStyle='#000'; ctx.fillRect(0,0,G.width,G.height);
            ctx.fillStyle='#111'; ctx.fillRect(0,G.groundY,G.width,G.height-G.groundY);
            ctx.fillStyle='#1a1a1a';
            for(let i=0;i<8;i++) ctx.fillRect((i*100)-((distance*0.2)%100),G.groundY-6-(i%2)*3,80,2);
            for(const obj of obstacles){
                if(obj.type==='box'){ const bx=Math.round(obj.x),by=G.groundY-obj.h; ctx.fillStyle='#8b4513'; ctx.fillRect(bx,by,obj.w,obj.h); ctx.strokeStyle='#5a2f0f'; ctx.strokeRect(bx,by,obj.w,obj.h); }
                else if(obj.type==='spike'){ const sx=Math.round(obj.x),sy=G.groundY-obj.h; ctx.fillStyle='#ff3333'; const tw=obj.w/3; for(let i=0;i<3;i++){ const px=sx+i*tw; ctx.beginPath(); ctx.moveTo(px,sy+obj.h); ctx.lineTo(px+tw/2,sy); ctx.lineTo(px+tw,sy+obj.h); ctx.closePath(); ctx.fill(); } }
                else if(obj.type==='gap'){ ctx.fillStyle='#111'; ctx.fillRect(Math.round(obj.x)-2,G.groundY-4,4,4); ctx.fillRect(Math.round(obj.x+obj.w)-2,G.groundY-4,4,4); }
                else if(obj.type==='flag'){ const fx=Math.round(obj.x),fy=G.groundY-obj.h; ctx.fillStyle='#ffcc00'; ctx.fillRect(fx,fy,6,obj.h); ctx.fillStyle='#ff3333'; ctx.beginPath(); ctx.moveTo(fx+6,fy); ctx.lineTo(fx+30,fy+14); ctx.lineTo(fx+6,fy+28); ctx.closePath(); ctx.fill(); }
            }
            ctx.save(); ctx.fillStyle=player.color; ctx.fillRect(Math.round(player.x),Math.round(player.y),player.size,player.size); ctx.fillStyle='rgba(0,0,0,0.15)'; ctx.fillRect(Math.round(player.x),Math.round(player.y)+player.size-6,player.size,6); ctx.restore();
            ctx.fillStyle='white'; ctx.font='18px monospace'; ctx.fillText('Dystans: '+Math.floor(distance)+'m',12,30);
            if(!gameStarted && !gameOver){ ctx.fillStyle='rgba(0,0,0,0.5)'; ctx.fillRect(0,0,G.width,G.height); ctx.fillStyle='white'; ctx.font='22px Arial'; ctx.fillText('Kliknij / Spacja Å¼eby START',G.width/2-140,G.height/2);}
            if(gameOver){ ctx.fillStyle='rgba(0,0,0,0.6)'; ctx.fillRect(0,0,G.width,G.height); ctx.fillStyle='white'; ctx.font='26px Arial'; ctx.fillText('KONIEC LEVELU',G.width/2-100,G.height/2-10); ctx.font='18px Arial'; ctx.fillText('Kliknij, Å¼eby zresetowaÄ‡',G.width/2-100,G.height/2+20);}
        }

        function loopGD(){ updateGD(); drawGD(); requestAnimationFrame(loopGD); }
        loopGD();

        /* ------------------------
           CS2 (pozostaÅ‚o bez zmian)
           ------------------------ */
        const cs2Canvas = document.getElementById('cs2Canvas');
        const g = cs2Canvas.getContext('2d');
        const W = cs2Canvas.width, H = cs2Canvas.height;
        let playerCS = { x: W/2, y: H/2, r: 12, dir: 0, speed: 2.5, hp: 100 };
        let bullets = [], enemies = [], keys = {}, mouse = { x:0, y:0, down:false }, cs2Running=false, cs2Score=0, cs2Paused=false;

        function spawnEnemy(){ const edge=Math.floor(Math.random()*4); let x,y; if(edge===0){x=-20;y=Math.random()*H;} if(edge===1){x=W+20;y=Math.random()*H;} if(edge===2){x=Math.random()*W;y=-20;} if(edge===3){x=Math.random()*W;y=H+20;} enemies.push({x,y,r:12,speed:1+Math.random()*1.2,hp:20}); }
        function startCs2(){ playerCS.x=W/2;playerCS.y=H/2;playerCS.hp=100;bullets=[];enemies=[];cs2Score=0;cs2Running=true;cs2Paused=false; for(let i=0;i<4;i++) spawnEnemy(); }
        function restartCs2(){ startCs2(); }
        document.getElementById('startCs2').addEventListener('click', startCs2);
        document.getElementById('restartCs2').addEventListener('click', restartCs2);
        cs2Canvas.addEventListener('mousemove',e=>{ const rect=cs2Canvas.getBoundingClientRect(); mouse.x=e.clientX-rect.left; mouse.y=e.clientY-rect.top; playerCS.dir=Math.atan2(mouse.y-playerCS.y,mouse.x-playerCS.x); });
        cs2Canvas.addEventListener('mousedown', e=>{ mouse.down=true; shoot(); });
        window.addEventListener('mouseup',e=>{ mouse.down=false; });
        window.addEventListener('keydown',e=>{ keys[e.key.toLowerCase()]=true; if(e.key.toLowerCase()==='p') cs2Paused=!cs2Paused; });
        window.addEventListener('keyup',e=>{ keys[e.key.toLowerCase()]=false; });
        function shoot(){ if(!cs2Running||cs2Paused) return; bullets.push({x:playerCS.x+Math.cos(playerCS.dir)*(playerCS.r+6),y:playerCS.y+Math.sin(playerCS.dir)*(playerCS.r+6),dx:Math.cos(playerCS.dir)*8,dy:Math.sin(playerCS.dir)*8,life:60}); }
        function updateCs2(){
            if(!cs2Running||cs2Paused) return;
            let mvx=0,mvy=0;
            if(keys['w']) mvy-=1; if(keys['s']) mvy+=1; if(keys['a']) mvx-=1; if(keys['d']) mvx+=1;
            const len=Math.hypot(mvx,mvy)||1; playerCS.x+=(mvx/len)*playerCS.speed; playerCS.y+=(mvy/len)*playerCS.speed;
            playerCS.x=Math.max(playerCS.r,Math.min(W-playerCS.r,playerCS.x)); playerCS.y=Math.max(playerCS.r,Math.min(H-playerCS.r,playerCS.y));
            for(let i=bullets.length-1;i>=0;i--){ let b=bullets[i]; b.x+=b.dx;b.y+=b.dy;b.life--; if(b.life<=0) bullets.splice(i,1);}
            for(let i=enemies.length-1;i>=0;i--){ let e=enemies[i]; const ang=Math.atan2(playerCS.y-e.y,playerCS.x-e.x); e.x+=Math.cos(ang)*e.speed; e.y+=Math.sin(ang)*e.speed; const dist=Math.hypot(e.x-playerCS.x,e.y-playerCS.y); if(dist<e.r+playerCS.r){ playerCS.hp-=10; enemies.splice(i,1);} }
            for(let i=enemies.length-1;i>=0;i--){ for(let j=bullets.length-1;j>=0;j--){ const e=enemies[i], b=bullets[j]; if(Math.hypot(e.x-b.x,e.y-b.y)<e.r+3){ e.hp-=20; bullets.splice(j,1); if(e.hp<=0){ enemies.splice(i,1); cs2Score+=100;} break;}}}
            if(Math.random()<0.02) spawnEnemy();
            if(playerCS.hp<=0){ cs2Running=false;}
            document.getElementById('playerHealth').textContent=Math.max(0,Math.floor(playerCS.hp));
            document.getElementById('cs2Score').textContent=cs2Score;
        }
        function drawCs2(){
            g.clearRect(0,0,W,H);
            g.fillStyle='green'; g.beginPath(); g.arc(playerCS.x,playerCS.y,playerCS.r,0,2*Math.PI); g.fill();
            g.fillStyle='red'; bullets.forEach(b=>{g.beginPath();g.arc(b.x,b.y,3,0,2*Math.PI);g.fill();});
            g.fillStyle='purple'; enemies.forEach(e=>{g.beginPath();g.arc(e.x,e.y,e.r,0,2*Math.PI);g.fill();});
        }
        function loopCs2(){ updateCs2(); drawCs2(); requestAnimationFrame(loopCs2);}
        loopCs2();
    </script>

    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5486175208501620"
     crossorigin="anonymous"></script>
</body>
</html>



